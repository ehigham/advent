module Advent.Day9 (main) where

import Control.Arrow             (first, second)
import Control.Exception         (throw)
import Control.Monad.RWS         (RWS, evalRWS, get, put, tell)
import Control.Monad             (replicateM_)
import Data.Either               qualified as E
import Data.Set                  qualified as S
import Data.Text.IO              qualified as T
import Prelude            hiding (Left, Right)
import Text.Parsec               (choice, parse, many, sepEndBy)
import Text.Parsec.Char          (char, digit, spaces)
import Text.Parsec.Text          (Parser)
import Text.Printf               (printf)

import Advent.Share.ParsecUtils  (ParseException(..))


-- | Part 1
--
-- This rope bridge creaks as you walk along it. You aren't sure how old it is,
-- or whether it can even support your weight.
--
-- It seems to support the Elves just fine, though. The bridge spans a gorge
-- which was carved out by the massive river far below you.
--
-- You step carefully; as you do, the ropes stretch and twist. You decide to
-- distract yourself by modeling rope physics; maybe you can even figure out
-- where not to step.
--
-- Consider a rope with a knot at each end; these knots mark the head and the
-- tail of the rope. If the head moves far enough away from the tail, the tail
-- is pulled toward the head.
--
-- Due to nebulous reasoning involving Planck lengths, you should be able to
-- model the positions of the knots on a two-dimensional grid. Then, by
-- following a hypothetical series of motions (your puzzle input) for the head,
-- you can determine how the tail will move.
--
-- Due to the aforementioned Planck lengths, the rope must be quite short; in
-- fact, the head (H) and tail (T) must always be touching (diagonally adjacent
-- and even overlapping both count as touching):
--
-- @
-- ....
-- .TH.
-- ....
--
-- ....
-- .H..
-- ..T.
-- ....
--
-- ...
-- .H. (H covers T)
-- ...
-- @
--
-- If the head is ever two steps directly up, down, left, or right from the
-- tail, the tail must also move one step in that direction so it remains close
-- enough:
--
-- @
-- .....    .....    .....
-- .TH.. -> .T.H. -> ..TH.
-- .....    .....    .....
--
-- ...    ...    ...
-- .T.    .T.    ...
-- .H. -> ... -> .T.
-- ...    .H.    .H.
-- ...    ...    ...
-- @
--
-- Otherwise, if the head and tail aren't touching and aren't in the same row or
-- column, the tail always moves one step diagonally to keep up:
--
-- @
-- .....    .....    .....
-- .....    ..H..    ..H..
-- ..H.. -> ..... -> ..T..
-- .T...    .T...    .....
-- .....    .....    .....
--
-- .....    .....    .....
-- .....    .....    .....
-- ..H.. -> ...H. -> ..TH.
-- .T...    .T...    .....
-- .....    .....    .....
-- @
--
-- You just need to work out where the tail goes as the head follows a series of
-- motions. Assume the head and the tail both start at the same position,
-- overlapping.
--
-- For example:
--
-- @
-- R 4
-- U 4
-- L 3
-- D 1
-- R 4
-- D 1
-- L 5
-- R 2
-- @
-- This series of motions moves the head right four steps, then up four steps,
-- then left three steps, then down one step, and so on. After each step, you'll
-- need to update the position of the tail if the step means the head is no
-- longer adjacent to the tail. Visually, these motions occur as follows (s
-- marks the starting position as a reference point):
--
-- == Initial State ==
--
-- @
-- ......
-- ......
-- ......
-- ......
-- H.....  (H covers T, s)
--
-- == R 4 ==
--
-- ......
-- ......
-- ......
-- ......
-- TH....  (T covers s)
--
-- ......
-- ......
-- ......
-- ......
-- sTH...
--
-- ......
-- ......
-- ......
-- ......
-- s.TH..
--
-- ......
-- ......
-- ......
-- ......
-- s..TH.
--
-- == U 4 ==
--
-- ......
-- ......
-- ......
-- ....H.
-- s..T..
--
-- ......
-- ......
-- ....H.
-- ....T.
-- s.....
--
-- ......
-- ....H.
-- ....T.
-- ......
-- s.....
--
-- ....H.
-- ....T.
-- ......
-- ......
-- s.....
--
-- == L 3 ==
--
-- ...H..
-- ....T.
-- ......
-- ......
-- s.....
--
-- ..HT..
-- ......
-- ......
-- ......
-- s.....
--
-- .HT...
-- ......
-- ......
-- ......
-- s.....
--
-- == D 1 ==
--
-- ..T...
-- .H....
-- ......
-- ......
-- s.....
--
-- == R 4 ==
--
-- ..T...
-- ..H...
-- ......
-- ......
-- s.....
--
-- ..T...
-- ...H..
-- ......
-- ......
-- s.....
--
-- ......
-- ...TH.
-- ......
-- ......
-- s.....
--
-- ......
-- ....TH
-- ......
-- ......
-- s.....
--
-- == D 1 ==
--
-- ......
-- ....T.
-- .....H
-- ......
-- s.....
--
-- == L 5 ==
--
-- ......
-- ....T.
-- ....H.
-- ......
-- s.....
--
-- ......
-- ....T.
-- ...H..
-- ......
-- s.....
--
-- ......
-- ......
-- ..HT..
-- ......
-- s.....
--
-- ......
-- ......
-- .HT...
-- ......
-- s.....
--
-- ......
-- ......
-- HT....
-- ......
-- s.....
--
-- == R 2 ==
--
-- ......
-- ......
-- .H....  (H covers T)
-- ......
-- s.....
--
-- ......
-- ......
-- .TH...
-- ......
-- s.....
-- @
-- After simulating the rope, you can count up all of the positions the tail
-- visited at least once. In this diagram, s again marks the starting position
-- (which the tail also visited) and # marks other positions the tail visited:
--
-- @
-- ..##..
-- ...##.
-- .####.
-- ....#.
-- s###..
-- @
--
-- So, there are 13 positions the tail visited at least once.
--
-- Simulate your complete hypothetical series of motions. How many positions
-- does the tail of the rope visit at least once?
part1 :: [(Direction, Int)] -> IO ()
part1 = printf "Unique number of positions tail visited = %d\n"
      . S.size
      . S.fromList
      . simulate


simulate :: [(Direction, Int)] -> [Point]
simulate steps = snd $ evalRWS (traverse eval steps) undefined start
  where
    start = ((0, 0), (0, 0))

    eval :: (Direction, Int) -> RWS a [Point] (Point, Point) ()
    eval (d, n) = replicateM_ n $ do
        (h, t) <- get
        let h' = move d h
            t' = chase h' t
        put (h', t')
        tell [t']

    -- (x, y) = (left-right, up-down)
    move :: Direction -> Point -> Point
    move Up    = second (+ 1)
    move Down  = second (subtract 1)
    move Left  = first  (subtract 1)
    move Right = first  (+ 1)


chase :: Point -> Point -> Point
chase (x0, y0) = go
  where
    go (x, y)
      |  abs (x - x0) > 1 || abs (y - y0) > 1
        = (x - signum (x - x0), y - signum (y - y0))

      | otherwise
         = (x, y)



-- | Part 2
part2 :: a -> IO ()
part2 _ = printf "not implemented\n"



data Direction = Up | Down | Left | Right
  deriving stock (Show, Eq)


type Point = (Int, Int)


inputParser :: Parser [(Direction, Int)]
inputParser = ((,) <$> direction <*> (spaces *> step)) `sepEndBy` spaces
  where
    direction = choice
      [ Up    <$ char 'U'
      , Down  <$ char 'D'
      , Left  <$ char 'L'
      , Right <$ char 'R'
      ]

    step = read <$> many digit


main :: FilePath -> IO ()
main inputFile = do
    contents <- T.readFile inputFile
    rounds <- case parse inputParser inputFile contents of
      E.Left err -> throw (ParseException err)
      E.Right rounds  -> pure rounds
    putStr "Part 1: "  >> part1 rounds
    putStr "Part 2: "  >> part2 rounds
